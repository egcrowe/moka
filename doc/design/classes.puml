@startuml

class Moka <<facade>> {
  start(Module) : MokaServer
  stop(MokaServer)
  replace(Moka, ...)
  load(Moka)
  history(Moka) : [{Fun, Args, Result}]
}

class MokaServer {

  start(Module)
  stop()
  replace_remote_call(Module, Function, Fun)
  load()
  history() : [{Fun, Args, Result}]
}

note as M1
  By remote call we refer to
  something like mod:fun(...)
end note

M1 .. MokaServer

class ModUtils <<library>> {
  get_abstract_code(Module)
  replace_remote_call(Abstact, CallTo = {Module, Function}, Fun)
  restore(Module)
}

note as M2
  The arity of Fun determines the arity
  of the remote call to replace
end note

M2 .. ModUtils

class AbsCode <<data>> {
  module
  source
}

class CallHandler {
  - behaviour: fun

  start()
  set_response_fun(Fun)
  get_response(Args)
}

class FunWorker  <<temporary>> {
  eval(Fun)
}

class History {
  - calls : [{Function, Args, Result}]

  add_call(Function, Args, Result)
  get_calls()
}

note as M3
  Any representation of
  erlang source code
end note
M3 .. AbsCode

class MainSup <<supervisor>> {
  start()
  start_new_moka()
}
class MokaSup <<supervisor>> {
  start()
  start_call_handler()
}

Moka ..> MainSup
Moka ..> MokaServer

MokaServer *--> "*" CallHandler
MokaServer *--> "1" AbsCode
MokaServer *--> "1" History
MokaServer  ..>     ModUtils
ModUtils    ..>     AbsCode

MainSup o--> "*" MokaSup     : <<creates>>
MokaSup o-->     MokaServer  : <<creates>>
MokaSup o--> "*" CallHandler : <<creates>>
MokaSup o-->     History     : <<creates>>
MokaSup o--> "*" FunWorker   : <<creates>>

CallHandler  ..>     History
CallHandler *--> "*" FunWorker
@enduml