@startuml

class Moka <<facade>> {
  start(Module) : MokaServer
  stop(MokaServer)
  replace(Moka, ...)
  load(Moka)
}

class MokaServer {

  start(Module)
  stop()
  replace_remote_call(Module, Function, Fun)
  load()
}

note as M1
  By remote call we refer to
  something like mod:fun(...)
end note

M1 .. MokaServer

class ModUtils <<library>> {
  get_abstract_code(Module)
  replace_remote_call(Abstact, CallTo = {Module, Function}, Fun)
  restore(Module)
}

note as M2
  The arity of Fun determines the arity
  of the remote call to replace
end note

M2 .. ModUtils

class AbsCode <<data>> {
  module
  source
}

class CallHandler {
  - behaviour: fun

  start()
  set_response_fun(Fun)
  get_response(Args)
  get_history() : [{Args, Return}]
}
note as M3
  Any representation of
  erlang source code
end note
M3 .. AbsCode

class MainSup <<supervisor>> {
  start()
  start_new_moka()
}
class MokaSup <<supervisor>> {
  start()
  start_call_handler()
}

Moka ..> MainSup
Moka ..> MokaServer

MokaServer *--> "*" CallHandler
MokaServer *--> "1" AbsCode
MokaServer ..> ModUtils
ModUtils ..> AbsCode

MainSup o--> "*" MokaSup : <<creates>>
MokaSup o--> MokaServer : <<creates>>
MokaSup o--> "*" CallHandler  : <<creates>>

@enduml